# rpc-go
my first golang's rpc project<br>


gRPC 中主要有四种请求/响应模式：(例子代码可参考,均实现了一个demo)
- 普通 RPC
- 服务端流式 RPC
- 客户端流式 RPC
- 服务端/客户端双向流式 RPC
## 随笔总结:
###### protobuf 是google开源的一个序列化框架，类似xml，json，最大的特点是基于二进制，比传统的XML表示同样一段内容要短小得多
###### gRPC 是 Google 开源的 RPC 框架和库，已支持主流计算机语言。底层通信采用 gRPC 协议(基于http2.0,支持双工流式通讯,支持并行处理多个请求,性能好,轻便)，比较适合互联网场景。gRPC 在设计上考虑了跟 ProtoBuf 的配合使用。
###### 典型的配合使用场景是，写好 .proto 描述文件定义 RPC 的接口，然后用 protoc（带 gRPC 插件）基于 .proto 模板自动生成各种编程语言的接口代码,我们可以继续基于接口代码去使用相应的编程语言编写我们需要的服务端和客户端业务代码,从而实现两端的rpc通讯

## 个人总结
###### 我通过自身的了解和学习认为grpc的性能优势快在两点: 
###### 1 两端之间基于grpc协议可以用数据流来收发消息,并且grpc协议基于HTTP2.0实现了真正的并行传输，它能够在一个TCP上进行任意数量HTTP请求。将一个/多个请求/响应拆分为多个帧,这些帧可以乱序发送，然后两端再根据每个帧头部的流标识符重新组装请求/响应。 
###### 2 grpc之间的数据传输（序列化/反序列化）协议用的是protobuf协议,传输二进制,比起xml/json传输性能高效
